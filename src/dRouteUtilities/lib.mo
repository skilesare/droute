///////////////////////////////
/*
Â©2021 RIVVIR Tech LLC
All Rights Reserved.
This code is released for code verification purposes. All rights are retained by RIVVIR Tech LLC and no re-distribution or alteration rights are granted at this time.
*/
///////////////////////////////

import Array "mo:base/Array";
import Buffer "mo:base/Buffer";
import DRouteTypes "../dRouteTypes/lib";
import Debug "mo:base/Debug";

import Hash "mo:base/Hash";
import Iter "mo:base/Iter";
import Nat16 "mo:base/Nat16";
import Nat32 "mo:base/Nat32";
import Nat8 "mo:base/Nat8";
import Principal "mo:base/Principal";
import Result "mo:base/Result";
import Sha256 "SHA256";
import Text "mo:base/Text";
import TrixTypes "../trixTypes/lib";
import MerkleTree "MerkleTree";


module {


    public func createEvent(_eventType : Text,
      _source : Principal,
      _userID : Nat,
      _dRouteID : Nat,
      _data : TrixTypes.AddressedChunkArray) : DRouteTypes.DRouteEvent{
        let result : DRouteTypes.DRouteEvent = {
            eventType = _eventType;
            source = _source;
            userID = _userID;
            dRouteID = _dRouteID;
            dataConfig = #dataIncluded{data = _data;};
          };
        return result;

    };

    /*
    public func toStableEvent(_event : DRouteTypes.DRouteEvent) : TrixTypes.AddressedChunkArray{
      //so far event is stable...why are we modifyingit?

        let fullBuffer : TrixTypes.AddressedChunkBuffer = Buffer.Buffer<TrixTypes.AddressedChunk>(16);
        let textBytes : [Nat8] = TrixTypes.textToBytes(_event.eventType);
        let principalBytes = TrixTypes.principalToBytes(_event.source);
        fullBuffer.add((0: Nat,0: Nat, textBytes));
        fullBuffer.add((1: Nat,0: Nat, principalBytes));
        fullBuffer.add((2: Nat,0: Nat, TrixTypes.natToBytes(_event.userID)));
        fullBuffer.add((3: Nat,0: Nat, TrixTypes.natToBytes(_event.dRouteID)));
        switch
        var zoneTracker : Nat = 4;
        for(thisZone : TrixTypes.DataZone in _event.data.vals()){
          var chunkTracker : Nat = 0;
          for(thisChunk : TrixTypes.DataChunk in thisZone.vals()){
            fullBuffer.add((zoneTracker, chunkTracker, thisChunk.toArray()));
            chunkTracker += 1;
          };
          zoneTracker += 1;
        };

        return fullBuffer.toArray();

    };
    */

    public func generateEventID(eventData : {source: Principal; eventType: Text; nonce: Nat; userID: Nat;}): Nat{
      //eventIDs are generated by publishing canisters.  They take a principal, an eventtype, and a nonce
      //the nonce should be stable such that event ids do not repeat

      TrixTypes.bytesToNat(Sha256.sha256(
        Array.append<Nat8>(
            TrixTypes.natToBytes(eventData.nonce),
        Array.append<Nat8>(
            TrixTypes.principalToBytes(eventData.source),
        Array.append<Nat8>(
            TrixTypes.textToBytes(eventData.eventType),
            TrixTypes.natToBytes(eventData.userID))))
      ));
    };


    public func generateSubscriptionID(subData : {source: Principal; eventType: Text; nonce: Nat; userID: Nat;}): Nat{
      //eventIDs are generated by publishing canisters.  They take a principal, an eventtype, and a nonce
      //the nonce should be stable such that event ids do not repeat

      TrixTypes.bytesToNat(Sha256.sha256(
        Array.append<Nat8>(
            TrixTypes.natToBytes(subData.nonce),
        Array.append<Nat8>(
            TrixTypes.principalToBytes(subData.source),
        Array.append<Nat8>(
            TrixTypes.textToBytes(subData.eventType),
            TrixTypes.natToBytes(subData.userID))))
      ));
    };


    public func eventRegistrationToStable(registration : DRouteTypes.EventRegistration): DRouteTypes.EventRegistrationStable{
      {
        eventType = registration.eventType;
        validSources = registration.validSources;
        publishingCanisters = registration.publishingCanisters;
      }
    };

    public func eventRegistrationFromStable(registration : DRouteTypes.EventRegistrationStable): DRouteTypes.EventRegistration{
      {
        eventType = registration.eventType;
        var validSources = registration.validSources;
        var publishingCanisters = registration.publishingCanisters;
      }
    };


    public func replaceDestinations(subInit : DRouteTypes.SubscriptionRequest, newDestinations: [Principal]): DRouteTypes.SubscriptionRequest{
      {
        eventType = subInit.eventType;
        filter = subInit.filter;
        throttle = subInit.throttle;
        destinationSet = newDestinations;
        userID = subInit.userID;
      };
    };

    public func serializeBroadcastLogItem(item : DRouteTypes.BroadcastLogItem) : TrixTypes.AddressedChunkArray{
      let result = Buffer.Buffer<(Nat, Nat, TrixTypes.TrixValue)>(16);
      result.add((0,0,#Text("com.droute.types.broadcastLogItem"))); //data type
      result.add((1,0,#Nat(1))); //version
      result.add((2,0,#Text(item.eventType))); //eventType
      result.add((3,0,#Nat(item.eventDRouteID))); //eventDRouteID
      result.add((4,0,#Nat(item.eventUserID))); //eventUserID
      result.add((5,0,#Principal(item.destination))); //destination
      result.add((6,0,#Principal(item.processor))); //processor
      result.add((7,0,#Nat(item.subscriptionUserID))); //subscriptionUserID
      result.add((8,0,#Nat(item.subscriptionDRoutID))); //subscriptionDRoutID
      result.add((9,0,#Nat(item.index))); //index
      result.add((10,0,#Nat(item.heapCycleID))); //heapCycleID
      result.add((11,0,#Int(item.dateSent))); //dateSent
      result.add((12,0,#Bool(item.notifyResponse))); //response
      switch(item.error){
        case(null){
          result.add((13,0,#Empty));
          result.add((13,1,#Empty));
        };
        case(?aErr){
          result.add((13,0,#Nat(aErr.code))); //errcode
          result.add((13,1,#Text(aErr.text))); //text error
        };
      };


      return result.toArray();

    };

    public func deserializeBroadcastLogItem(item : TrixTypes.AddressedChunkArray) :  ?DRouteTypes.BroadcastLogItem{

        let version : Nat = TrixTypes.valueToNat(item[1].2);

            if(version == 1){
              return ?{

                eventType = TrixTypes.valueToText(item[2].2); //eventType
                eventDRouteID =TrixTypes.valueToNat(item[3].2); //eventDRouteID
                eventUserID =TrixTypes.valueToNat(item[4].2); //eventUserID
                destination =TrixTypes.valueToPrincipal(item[5].2); //destination
                processor =TrixTypes.valueToPrincipal(item[6].2); //processor
                subscriptionUserID =TrixTypes.valueToNat(item[7].2); //subscriptionUserID
                subscriptionDRoutID =TrixTypes.valueToNat(item[8].2); //subscriptionDRoutID
                index =TrixTypes.valueToNat(item[9].2); //index
                heapCycleID =TrixTypes.valueToNat(item[10].2); //heapCycleID
                dateSent =TrixTypes.valueToNat(item[11].2); //datesent
                notifyResponse = TrixTypes.valueToBool(item[12].2); //notifyResponse
                error = switch(item[13].2){
                    case(#Empty){
                      null;
                    };
                    case(_){
                      ?{code = TrixTypes.valueToNat(item[13].2);
                      text = TrixTypes.valueToText(item[14].2)};
                    };

                  };

              };
            } else {
              return null;
            };
    };



  };



