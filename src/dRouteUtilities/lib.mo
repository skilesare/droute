///////////////////////////////
/*
Â©2021 RIVVIR Tech LLC
All Rights Reserved.
This code is released for code verification purposes. All rights are retained by RIVVIR Tech LLC and no re-distribution or alteration rights are granted at this time.
*/
///////////////////////////////

import Array "mo:base/Array";
import Buffer "mo:base/Buffer";
import DRouteTypes "../dRouteTypes/lib";
import Debug "mo:base/Debug";

import Hash "mo:base/Hash";
import Iter "mo:base/Iter";
import Nat16 "mo:base/Nat16";
import Nat32 "mo:base/Nat32";
import Nat8 "mo:base/Nat8";
import Principal "mo:base/Principal";
import Result "mo:base/Result";
import Sha256 "SHA256";
import Text "mo:base/Text";
import TrixTypes "../trixTypes/lib";
import MerkleTree "MerkleTree";


module {


    public func createEvent(_eventType : Text,
      _source : Principal,
      _userID : Nat,
      _dRouteID : Nat,
      _data : TrixTypes.AddressedChunkArray) : DRouteTypes.DRouteEvent{
        let result : DRouteTypes.DRouteEvent = {
            eventType = _eventType;
            source = _source;
            userID = _userID;
            dRouteID = _dRouteID;
            dataConfig = #dataIncluded{data = _data;};
          };
        return result;

    };

    /*
    public func toStableEvent(_event : DRouteTypes.DRouteEvent) : TrixTypes.AddressedChunkArray{
      //so far event is stable...why are we modifyingit?

        let fullBuffer : TrixTypes.AddressedChunkBuffer = Buffer.Buffer<TrixTypes.AddressedChunk>(16);
        let textBytes : [Nat8] = TrixTypes.textToBytes(_event.eventType);
        let principalBytes = TrixTypes.principalToBytes(_event.source);
        fullBuffer.add((0: Nat,0: Nat, textBytes));
        fullBuffer.add((1: Nat,0: Nat, principalBytes));
        fullBuffer.add((2: Nat,0: Nat, TrixTypes.natToBytes(_event.userID)));
        fullBuffer.add((3: Nat,0: Nat, TrixTypes.natToBytes(_event.dRouteID)));
        switch
        var zoneTracker : Nat = 4;
        for(thisZone : TrixTypes.DataZone in _event.data.vals()){
          var chunkTracker : Nat = 0;
          for(thisChunk : TrixTypes.DataChunk in thisZone.vals()){
            fullBuffer.add((zoneTracker, chunkTracker, thisChunk.toArray()));
            chunkTracker += 1;
          };
          zoneTracker += 1;
        };

        return fullBuffer.toArray();

    };
    */

    public func generateEventID(eventData : {source: Principal; eventType: Text; nonce: Nat; userID: Nat;}): Nat{
      //eventIDs are generated by publishing canisters.  They take a principal, an eventtype, and a nonce
      //the nonce should be stable such that event ids do not repeat

      TrixTypes.bytesToNat(Sha256.sha256(
        Array.append<Nat8>(
            TrixTypes.natToBytes(eventData.nonce),
        Array.append<Nat8>(
            TrixTypes.principalToBytes(eventData.source),
        Array.append<Nat8>(
            TrixTypes.textToBytes(eventData.eventType),
            TrixTypes.natToBytes(eventData.userID))))
      ));
    };


    public func generateSubscriptionID(subData : {source: Principal; eventType: Text; nonce: Nat; userID: Nat;}): Nat{
      //eventIDs are generated by publishing canisters.  They take a principal, an eventtype, and a nonce
      //the nonce should be stable such that event ids do not repeat

      TrixTypes.bytesToNat(Sha256.sha256(
        Array.append<Nat8>(
            TrixTypes.natToBytes(subData.nonce),
        Array.append<Nat8>(
            TrixTypes.principalToBytes(subData.source),
        Array.append<Nat8>(
            TrixTypes.textToBytes(subData.eventType),
            TrixTypes.natToBytes(subData.userID))))
      ));
    };


    public func eventRegistrationToStable(registration : DRouteTypes.EventRegistration): DRouteTypes.EventRegistrationStable{
      {
        eventType = registration.eventType;
        validSources = registration.validSources;
        publishingCanisters = registration.publishingCanisters;
      }
    };

    public func eventRegistrationFromStable(registration : DRouteTypes.EventRegistrationStable): DRouteTypes.EventRegistration{
      {
        eventType = registration.eventType;
        var validSources = registration.validSources;
        var publishingCanisters = registration.publishingCanisters;
      }
    };


    public func replaceDestinations(subInit : DRouteTypes.SubscriptionRequest, newDestinations: [Principal]): DRouteTypes.SubscriptionRequest{
      {
        eventType = subInit.eventType;
        filter = subInit.filter;
        throttle = subInit.throttle;
        destinationSet = newDestinations;
        userID = subInit.userID;
      };
    };

    public func serializeBroadcastLogItem(item : DRouteTypes.BroadcastLogItem) : TrixTypes.AddressedChunkArray{
      let result = Buffer.Buffer<(Nat, Nat, [Nat8])>(16);
      result.add((0,0,TrixTypes.textToBytes("com.droute.types.broadcastLogItem"))); //data type
      result.add((1,0,TrixTypes.natToBytes(1))); //version
      result.add((2,0,TrixTypes.textToBytes(item.eventType))); //eventType
      result.add((3,0,TrixTypes.natToBytes(item.eventDRouteID))); //eventDRouteID
      result.add((4,0,TrixTypes.natToBytes(item.eventUserID))); //eventUserID
      result.add((5,0,TrixTypes.principalToBytes(item.destination))); //destination
      result.add((6,0,TrixTypes.principalToBytes(item.processor))); //processor
      result.add((7,0,TrixTypes.natToBytes(item.subscriptionUserID))); //subscriptionUserID
      result.add((8,0,TrixTypes.natToBytes(item.subscriptionDRoutID))); //subscriptionDRoutID
      result.add((9,0,TrixTypes.natToBytes(item.index))); //index
      result.add((10,0,TrixTypes.natToBytes(item.heapCycleID))); //heapCycleID
      result.add((11,0,TrixTypes.intToBytes(item.dateSent))); //dateSent
      result.add((12,0,TrixTypes.boolToBytes(item.notifyResponse))); //response
      switch(item.error){
        case(null){
          result.add((13,0,[]));
          result.add((13,1,[]));
        };
        case(?aErr){
          result.add((13,0,TrixTypes.natToBytes(aErr.code))); //errcode
          result.add((13,1,TrixTypes.textToBytes(aErr.text))); //text error
        };
      };


      return result.toArray();

    };

    public func deserializeBroadcastLogItem(item : TrixTypes.AddressedChunkArray) :  ?DRouteTypes.BroadcastLogItem{
      let version = TrixTypes.bytesToNat(item[1].2);
      if(version == 1){
        return ?{

          eventType =TrixTypes.bytesToText(item[2].2); //eventType
          eventDRouteID =TrixTypes.bytesToNat(item[3].2); //eventDRouteID
          eventUserID =TrixTypes.bytesToNat(item[4].2); //eventUserID
          destination =TrixTypes.bytesToPrincipal(item[5].2); //destination
          processor =TrixTypes.bytesToPrincipal(item[6].2); //processor
          subscriptionUserID =TrixTypes.bytesToNat(item[7].2); //subscriptionUserID
          subscriptionDRoutID =TrixTypes.bytesToNat(item[8].2); //subscriptionDRoutID
          index =TrixTypes.bytesToNat(item[9].2); //index
          heapCycleID =TrixTypes.bytesToNat(item[10].2); //heapCycleID
          dateSent =TrixTypes.bytesToNat(item[11].2); //datesent
          notifyResponse = TrixTypes.bytesToBool(item[12].2); //notifyResponse

          error = if(item[13].2.size() > 0){
            ?{code = TrixTypes.bytesToNat(item[13].2);
              text = TrixTypes.bytesToText(item[14].2)}
            } else {
              null
            };
          };
      };

      return null;
    };



  };



