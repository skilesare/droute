///////////////////////////////
/*
Â©2021 RIVVIR Tech LLC
All Rights Reserved.
This code is released for code verification purposes. All rights are retained by RIVVIR Tech LLC and no re-distribution or alteration rights are granted at this time.
*/
///////////////////////////////

import Array "mo:base/Array";
import Buffer "mo:base/Buffer";
import DRouteTypes "../dRouteTypes/lib";
import Debug "mo:base/Debug";

import Hash "mo:base/Hash";
import Iter "mo:base/Iter";
import Nat16 "mo:base/Nat16";
import Nat32 "mo:base/Nat32";
import Nat8 "mo:base/Nat8";
import Principal "mo:base/Principal";
import Result "mo:base/Result";
import Sha256 "SHA256";
import String "mo:base/Text";
import Text "mo:base/Text";
import TrixTypes "../trixTypes/lib";
import MerkleTree "MerkleTree";


module {


    public func createEvent(_eventType : Text,
      _source : Principal,
      _userID : Nat,
      _dRouteID : Nat,
      _data : TrixTypes.AddressedChunkArray) : DRouteTypes.DRouteEvent{
        let result : DRouteTypes.DRouteEvent = {
            eventType = _eventType;
            source = _source;
            userID = _userID;
            dRouteID = _dRouteID;
            dataConfig = #dataIncluded{data = _data;};
          };
        return result;

    };

    /*
    public func toStableEvent(_event : DRouteTypes.DRouteEvent) : TrixTypes.AddressedChunkArray{
      //so far event is stable...why are we modifyingit?

        let fullBuffer : TrixTypes.AddressedChunkBuffer = Buffer.Buffer<TrixTypes.AddressedChunk>(16);
        let textBytes : [Nat8] = TrixTypes.textToBytes(_event.eventType);
        let principalBytes = TrixTypes.principalToBytes(_event.source);
        fullBuffer.add((0: Nat,0: Nat, textBytes));
        fullBuffer.add((1: Nat,0: Nat, principalBytes));
        fullBuffer.add((2: Nat,0: Nat, TrixTypes.natToBytes(_event.userID)));
        fullBuffer.add((3: Nat,0: Nat, TrixTypes.natToBytes(_event.dRouteID)));
        switch
        var zoneTracker : Nat = 4;
        for(thisZone : TrixTypes.DataZone in _event.data.vals()){
          var chunkTracker : Nat = 0;
          for(thisChunk : TrixTypes.DataChunk in thisZone.vals()){
            fullBuffer.add((zoneTracker, chunkTracker, thisChunk.toArray()));
            chunkTracker += 1;
          };
          zoneTracker += 1;
        };

        return fullBuffer.toArray();

    };
    */

    public func generateEventID(eventData : {source: Principal; eventType: Text; nonce: Nat; userID: Nat;}): Nat{
      //eventIDs are generated by publishing canisters.  They take a principal, an eventtype, and a nonce
      //the nonce should be stable such that event ids do not repeat

      TrixTypes.bytesToNat(Sha256.sha256(
        Array.append<Nat8>(
            TrixTypes.natToBytes(eventData.nonce),
        Array.append<Nat8>(
            TrixTypes.principalToBytes(eventData.source),
        Array.append<Nat8>(
            TrixTypes.textToBytes(eventData.eventType),
            TrixTypes.natToBytes(eventData.userID))))
      ));
    };


    public func generateSubscriptionID(subData : {source: Principal; eventType: Text; nonce: Nat; userID: Nat;}): Nat{
      //eventIDs are generated by publishing canisters.  They take a principal, an eventtype, and a nonce
      //the nonce should be stable such that event ids do not repeat

      TrixTypes.bytesToNat(Sha256.sha256(
        Array.append<Nat8>(
            TrixTypes.natToBytes(subData.nonce),
        Array.append<Nat8>(
            TrixTypes.principalToBytes(subData.source),
        Array.append<Nat8>(
            TrixTypes.textToBytes(subData.eventType),
            TrixTypes.natToBytes(subData.userID))))
      ));
    };


    public func eventRegistrationToStable(registration : DRouteTypes.EventRegistration): DRouteTypes.EventRegistrationStable{
      {
        eventType = registration.eventType;
        validSources = registration.validSources;
        publishingCanisters = registration.publishingCanisters;
      }
    };

    public func eventRegistrationFromStable(registration : DRouteTypes.EventRegistrationStable): DRouteTypes.EventRegistration{
      {
        eventType = registration.eventType;
        var validSources = registration.validSources;
        var publishingCanisters = registration.publishingCanisters;
      }
    };


    public func replaceDestinations(subInit : DRouteTypes.SubscriptionRequest, newDestinations: [Principal]): DRouteTypes.SubscriptionRequest{
      {
        eventType = subInit.eventType;
        filter = subInit.filter;
        throttle = subInit.throttle;
        destinationSet = newDestinations;
        userID = subInit.userID;
      };
    };




};